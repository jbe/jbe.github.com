---
layout: post
title: "Scheduling"
published: true
categories:
  - Notes
  - UiO
  - inf1060
---

Kjøring av et program kalles en *prosess*. Kan betraktes som en abstraksjon benyttet av OS-et for å holde styr på hva som skjer.

Kjernen har en tabell over prosessser (pcb)

Systemkall, slik som @fork@, kan opprette prosesser. @fork@ returnerer forskjellig verdi, avhengig av om den er i foreldre- eller barne-prosessen. Negativ hvis fail, 0 hvis barn, pid hvis foreldre.

@clone@ lar applikasjonene fortsette å dele ressurser.
@vfork@ lar forelsre vente til barn er ferdig.

*Terminering* av prosesser skjer ved at man returnerer en verdi, eller bruker et systemkall, slik som @exit@ eller @kill@.

@int execve(char *filename, char *params[], char *envp[])* overfører kontroll til en annen prosess.

*Synkronisering mellom foreldre og barn* kan også gjøres via systemkall.

@pid_t wait(int *status)@
Return:
|-1|ingen barneprosesser|
|pid|pid til terminert barneprosesss, putter status i *status|

se ogsp @wait4@ og @waitpid@

*Context switching* er den mekanismen som pakker ned, tar vare på, og gjeninsetter innholdet av registre, instruksjonspreker osv, når kontrollen overføres mellom programmer i time-sharing. Relativt dyr, må optimaliseres. Noe hardware-støtte hos general purpose-registre.

Noe av tanken bak *tråder*, er at de kan dele ressurser, slik som adresserom. Switchingen blir dermed billigere.

En *scheduler* bestemmer hvem som får tilgang til ressurser, etter en *scheduling-algoritme*.
