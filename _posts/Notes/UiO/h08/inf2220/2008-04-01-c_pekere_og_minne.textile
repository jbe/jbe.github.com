---
layout: post
title: "C: Pekere og minne"
published: true
categories:
  - Notes
  - UiO
  - inf1060
  - C
---

Vanlige variabler i et kompilert C-program befinner seg innenfor _programkjernen_ i minne. De har altså tildelt sin egen plass i minnet, innenfor selve programmet.

*Pekere* er en mekanisme for å la variable inneholde en minneadresse, som kan leses av i steden for selve variabelen. Når en variabel brukes som en peker, slår vi altså opp og leser av minnet på adressen som svarer til denne variabelens verdi.

Dette åpner muligheter som kan henge sammen med objektorientering i andre språk. Pekerne gjør det for eksempel mulig å _dynamisk allokere_ minne  utenfor det som i utgangspunktet er allokert for kjernen av programmet, etter hvert som behovet oppstår.

Pekere i C håndteres ved hjelp av disse to krabatene:

|@&var@|minneadressen som huser @var@|
|@*var@|innholdet av minneadressen @var@|

Hvis man skriver @foo = &bar@ blir @foo@ en peker til @bar@. @*foo@ vil deretter gi oss bar.

En peker kan deklareres etter disse mønstrene:

<pre name="code" class="c:nocontrols">
int* i;
int *i;
</pre>

I c sendes *funksjonsparametre* som verdier, ikke referanser. Destruktive funksjoner får man ved å gi funksjonen pekere:

<pre name="code" class="c:nocontrols">
void sum(int a, int b, int *result){
      *result = a + b;
}

int main(){
      int r;
      sum(2, 3, &r);
      return 0;
}
</pre>

Dette er vanlig for funksjoner som arbeider med strenger.

*Dynamimsk allokering* av minne gjøres vanligvis med @malloc(sizeof(int))@, som ligger i @stdlib.h@. Parameteret angir byte-størrelse. Malloc returnerer en void-peker som må castes. Minnet frigis med @free(p)@.

*Pekerpeker*, altså en peker som peker til en peker, kan skrives @**p@. Også videre.

*Lekasje* inntreffer når vi allokerer minne, og deretter ødelegger pekeren, slik at minnet ikke kan frigis. Det er flaut.

*Relaterte konvensjoner:*

Innholdet av en vektorvariabl er egentlig en peker til vektorens første element.

@a[i]@ er det samme som @*(a+i)@.

Det er egne regneregler for pekere: @p+i@ svarer til _p_ + (_i_ &middot; _størrelsen av det p peker på_).

Disse er dermed ekvivalente:

<pre name="code" class="c:nocontrols">
char *c  = "hmmm";
char c[] = "hmmm";
char c[] = {'h', 'm', 'm'};
</pre>

*Struct-pekere* har også en kjekk konvensjon:

<pre name="code" class="c:nocontrols">
p = (struct Person*) malloc(sizeof(struct Person));
// vi kan nå bruke p->age som en shorthand for (*p).age
</pre>

*OBS:*

C sjekker ikke indeksen i vektorer (arrays). Man kan dermed ende opp med å modifisere andre deler av minnet!

Det er implementasjonsavhenging om vektorene nulles ut når de opprettes. Derfor bør man ofte eksplisitt ordne dette.

